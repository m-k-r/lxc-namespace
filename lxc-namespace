#!/bin/bash
#
# -----------------------------------------------------------------------------
#
# Author:	Marcel Keller (m-k-r)
# Usage:	change the namespace of a lxc-container
# License:	GPLv3 http://www.gnu.org/licenses/gpl-3.0
#
# ----------------------------- Global Variables ------------------------------

version=0.2
usage="usage: lxc-namespace [parameter]

 -c	name of the container
 -m	mode: change (default), check (if files are in range)
 -n	number (can be number:number and number for both)
 -p	path to the container
 -v	show version of this script
 -h	this page"
path=/var/lib/lxc
supported_mode="change check"
mode=change
integers_change="uid_config gid_config uid_rootfs gid_rootfs"
integers_check="uid_config gid_config uid_config_range gid_config_range"

# --------------------------------- Parameter ---------------------------------

if [ "$#" == "0" ]
	then	echo "$usage" && exit 0
fi

while getopts ":c:m:n:p:vh" opt; do
	case ${opt} in
		c)	arg_container=$OPTARG
			;;
		m)	mode=$OPTARG
			;;
		n)	arg_id=$OPTARG
			;;
		p)	path=$OPTARG
			;;
		v)	echo "${version}"
			exit 0
			;;
		h)	echo "${usage}"
			exit 0
			;;
		?)	echo "Invalid option: -$OPTARG" >&2
			exit 1
			;;
	esac
done

# --------------------------------- Config -------------------------------------

# paths
container=${path}/${arg_container}
rootfs=${container}/rootfs
config=${container}/config

# check if container/rootfs exists
probe=$(find ${rootfs} -maxdepth 0 2>&1)
if [[ ! "${probe}" == "${rootfs}" ]]; then
	echo "the container: ${arg_container} does not exist" && exit 1
fi

# check if mode is supported
probe=$(echo ${supported_mode} | grep "\b${mode}\b")
if [[ ! -n "${probe}" ]]; then
	echo "${mode} is not a viable mode" && exit 1
fi

# if uid:gid is given split it, else use number for both
# get config_ids if arg_id is set
if [[ -n "${arg_id}" ]]; then
	probe=$(echo "$arg_id" | grep ":")
	if [[ -n "${probe}" ]]; then
		uid_config=$(echo "${arg_id}")
		gid_config=$(echo "${arg_id}"); else
		uid_config=${arg_id}
		gid_config=${arg_id}
	fi
fi

# get elements from rootfs
elements=$(find "${rootfs}"/ | sed 's/ /\\ /g')

# ------------------------------- Functions ------------------------------------

##### helper functions #####
function check-integer () {
	for integer in ${1}
	do	if [[ ! "${!integer}" =~ ^-?[0-9]+$ ]]; then
			echo "${integer}: ${!integer} is no uig/gid" && exit 1
		fi
	done
}

# chown removes sticky bits out ouf security considerations. chmod to before to get sticky bits back
# if permissions are compared only sticky bits are affected. this omits symlinks and other problematic files like /dev/*
function change-absolute {
	while read element
	do	permissions_old=$(stat -c %a "${element}")
		chown -h "${uid_config}":"${gid_config}" "${element}"
		permissions_new=$(stat -c %a "${element}")
		if [[ ! "${permissions_new}" == "${permissions_old}" ]]; then
			chmod "${permissions_old}" "${element}"
		fi
	done <<< "${elements}"
}

# change owner:group relative to existing mapping
function change-relative {
	while read element
	do	permissions_old=$(stat -c %a "${element}")
		uid_old=$(stat -c %u "${element}")
		gid_old=$(stat -c %g "${element}")
		uid_new=$((${uid_old} ${operator_uid} ${uid_diff}))
		gid_new=$((${gid_old} ${operator_gid} ${gid_diff}))
		chown -h "${uid_new}":"${gid_new}" "${element}"
		permissions_new=$(stat -c %a "${element}")
		if [[ ! "${permissions_new}" == "${permissions_old}" ]]; then
			chmod "${permissions_old}" "${element}"
		fi
	done <<< "${elements}"
}

function check-hardlinks {
	# get all files with more than one hardlink
	hardlinks_multi=$(find "${rootfs}"/ -type f -links +1 2>/dev/null | sed 's/ /\\ /g')
	hardlinks_multi_number=$(echo "${hardlinks_multi}" | sed '/^\s*$/d' | awk 'END{print NR}')
	echo "found ${hardlinks_multi_number} multiple hardlink(s). Filter out the redundant"
	# get all redundant hardlinks
	while read hardlink_multi
	do	# get all hardlinks to file
		hardlinks_to_inode=($(find "${rootfs}"/ -samefile "${hardlink_multi}" | sed 's/ /\\ /g'))
		probe=$(echo "${hardlinks_known}" | grep -w "${hardlinks_to_inode[0]}")
		# check if file is already known. if one hardlink is known all hardlinks to inode are known
		if [[ -n "${probe}" ]]; then
			# if inode is already known remove hardlink from elements
			elements=$(echo "${elements}" | grep -vw "${hardlink_multi}"); else
			# if hardlink is not known its uid:gid has to be changed
			hardlinks_known+=${hardlinks_to_inode[@]}$'\n'
		fi
	done <<< "${hardlinks_multi}"
	echo "done"
	unset hardlinks_multi hardlink_multi hardlinks_multi_number hardlinks_to_inode hardlinks_known
}

function check-mapping {
	while read element
	do	uid_old=$(stat -c %u "${element}")
		gid_old=$(stat -c %g "${element}")

		if [[ "${uid_old}" -lt "${uid_config}" ]] || [[ "${uid_old}" -gt "${uid_limit}" ]] || [[ "${gid_old}" -lt "${gid_config}" ]] || [[ "${gid_old}" -gt "${gid_limit}" ]]; then
			elements_repair+=${element}$'\n'
			output+="${uid_old}:${gid_old} ${element}"$'\n'
		fi
	done <<< "${elements}"
	elements_repair=($(echo "${elements_repair}" | grep -v '^$'))
}

function get-diff {
	uid_diff=$((${uid_config} - ${uid_rootfs}))
	gid_diff=$((${gid_config} - ${gid_rootfs}))

	if [[ "${uid_diff}" -lt "0" ]]; then
		operator_uid="-"
		uid_diff=$(echo "${uid_diff}" | cut -c 2-); else
		operator_uid="+"
	fi

	if [[ "${gid_diff}" -lt "0" ]]; then
		operator_gid="-"
		gid_diff=$(echo "${gid_diff}" | cut -c 2-); else
		operator_gid="+"
	fi
}

# get user mapping from config, container and rootfs
function get-mapping {
	if [[ ! -n "${uid_config}" ]]; then
		uid_config=$(awk -v condition1="lxc.id_map" -v condition2="u" '$1 == condition1 && $3 == condition2 { print $5 }' ${config} 2>&1)
		gid_config=$(awk -v condition1="lxc.id_map" -v condition2="g" '$1 == condition1 && $3 == condition2 { print $5 }' ${config} 2>&1)
	fi

	if [[ ! "${mode}" == "change" ]]; then
		uid_config_range=$(awk -v condition1="lxc.id_map" -v condition2="u" '$1 == condition1 && $3 == condition2 { print $6 }' ${config} 2>&1)
		gid_config_range=$(awk -v condition1="lxc.id_map" -v condition2="g" '$1 == condition1 && $3 == condition2 { print $6 }' ${config} 2>&1)
	fi

	uid_rootfs=$(stat -c %u "${rootfs}")
	gid_rootfs=$(stat -c %g "${rootfs}")
}

# ------------------------------ Main Script -----------------------------------

# get existing mapping and create diff
get-mapping
elements_number=$(echo "${elements}" | sed '/^\s*$/d' | awk 'END{print NR}')
echo "processing uid/gid for ${elements_number} files and directories in rootfs."
echo "maybe you want to get a coffee, this may take a while..."
echo "-----"

if [[ "${mode}" == "change" ]]; then
	# check if ids are integer
	check-integer "${integers_change}"
	get-diff
	# if a file or directory is hardlinked multiple times the changes are applied multiple times.
	# so all but one hardlink per inode has to be filtered out
	if [[ ! "${uid_diff}:${gid_diff}" == "0:0" ]]; then
		check-hardlinks
		echo "change ${uid_rootfs}:${gid_rootfs} to ${uid_config}:${gid_config}"
		change-relative
	fi

	# change container to configured uid/gid and restrict access to owner
	elements=${container}
	change-absolute
	chmod 700 ${container};
elif [[ "${mode}" == "check" ]]; then
	# check if ids are integer
	check-integer "${integers_check}"
	uid_limit=$((${uid_config} + ${uid_config_range}))
	gid_limit=$((${gid_config} + ${gid_config_range}))
	echo "check if files are in range of ${uid_config}:${gid_config} to ${uid_limit}:${gid_limit}"
	check-mapping

	if [[ -n "${elements_repair}" ]]; then
		elements_repair_number=$(echo "${elements_repair}" | sed '/^\s*$/d' | awk 'END{print NR}')
		output=$(echo "${output}" | grep -v '^$')
		echo "the following ${elements_repair_number} file(s) or directories are out of range:"
		echo "${output}"
		read -p "do you want to give these ${elements_repair_number} file(s) and directories to the containers root-user ${uid_config}:${gid_config}?"$'\n' do_repair

		if [[ "${do_repair}" == 'y' ]] || [[ "${do_repair}" == 'yes' ]] || [[ "${do_repair}" == 'j' ]]; then
			elements=${elements_repair}
			change-absolute; else
			echo "nothing changed"
		fi; else
		echo "looks fine. all files within range"
	fi
fi
